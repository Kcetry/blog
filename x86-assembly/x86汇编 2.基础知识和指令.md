一.知识点
汇编地址和偏移地址是一一对应的

主引导扇区会被加载到0x0000:0x7c00处,这就意味着此时cs=0x0000,ip=0x7c00

二进制可以用下划线_:mov ax,0000_0000_1111B

标号仅表示内存地址

64位的寄存器依旧保留之前的用法 r8-r15只能作为64位整体来用

8086上 只能由bx,si,di,bp提供偏移地址

8086只能压入一个字 其后的32位64位允许压入字双字四字

BIOS是对不同类型的计算机的底层屏蔽

$$ 表示当前段的起始汇编地址 当程序没有定义段 就默认为0

equ不占用汇编地址

8086不能压入立即数 现代的cpu可以

8086寻址方式:
1.基址寻址:把内存单元放在bx或者bp中
采用bp作为基址时 默认的段寄存器是SS 可用于访问栈:
mov ax,0x5000
push ax
mov bp,sp
mov ax,0x7000
push ax
mov dx,[bp]
2.变址寻址:
mov [si],dx
mov ax,[di]
处理器会将DS作为段地址,SI或DI作为偏移地址
3.基址变址寻址:
mov ah,[bx+si]
处理器会将DS作为段地址,bx+si作为偏移地址

二.指令
mov指令:
mov 内存地址 寄存器
mov 内存地址 立即数
mov 寄存器 立即数
mov 寄存器 内存地址
mov 寄存器 寄存器

div指令
1.16bit除以8bit:被除数放在ax,除数放在8位寄存器或内存地址,商在AL,余数在AH
2.32bit除以16bit:被除数高16bit放在dx,低16bit放在ax,商在ax,余数在dx
可以引用内存地址:div byte [地址]([段寄存器:地址])

idiv指令 有符号除法 做32位除法前 用cwd指令扩展ax到dx

neg指令 用0减去指令中指定的操作数

cbw指令 将AL的有符号数扩展到AX

cbd指令 将AX中的有符号数扩展到DX

sub指令 ah,al == neg al; add ah,al

xor指令
相同为0不相同为1 目的操作数可以是通用寄存器或内存单元 原操作数是通用寄存器或内存单元 有位限制

add指令
add al,cl
add ax,0x123f
add [label_a],cx
add ax,[label_a]
add byte [label_a], 0x08

jmp 等指令
(详见x86汇编从实模式到保护模式 p65)
jmp 段地址:偏移地址 将把段地址赋给cs,偏移地址赋给ip
jmp near 标号 说明:该跳转是相对跳转,偏移量=目标地址减去该指令地址(开头)再减去该指令长度(3) 
如何跳转:处理器执行完指令后ip+=3,让后ip-=偏移量 类似于这种方式就称为相对近转移(16位)
near仅仅用于表示偏移量是16位的 jmp 标号才是关键
jmp near $ 转移到当前指令执行
js sf=1转移 jns sf=0转移 下同
jo  jno 
jc  jnc
jp  jnp
jcxz 当cx的内容为0时转移
寻址
1.相对短转移 操作数是有符号的1字节数,属于段内转移指令,范围是-128-127,必须使用关键字short:
jmp short 标号
编译器会检查标号,如果超过1字节,编译无法通过
2.16位相对近转移
和短转移一样 只不过操作数是2字节 应当使用关键字near 如果不声明nasm会自动根据距离自动采用short或near
3.16位间接绝对近转移
jmp near bx
会将bx的值赋给ip near可省略 也可以用其它的寻址方式
jmp [bx]
jmp [bx+si]
会先到内存地址bx取出地址,然后跳到该地址
sign dw db 0xc000
jmp [sign] 实际上是 jmp 0xc000
4.16位直接绝对远转移
jmp 0x0000:0x7c00
5.16位间接绝对远转移
sign dw 0x33c0,0xf000
jmp far [sign]会将高字0xf000赋给cs,低字0x33c0赋给ip
jmp [bx+si+0x02] jmp [bx+si]都是可以的

call指令
跳转的代码段内首先要压栈,最后要出栈
8086支持4种call的调用方式
1.16位相对近调用
call near 标号(near不是必须的)
像之前的jmp一样,是用标号的地址-该指令的地址(开头)-该指令的长度得到偏移量
该偏移量是16位的有符号数 所以跳转的范围是-32768-32767
执行时,ip会把当前值压栈,然后该偏移量传给ip,导致跳转
call 0x0500
注意 该语句的执行也是像上面一样 0x0500相当于是个标号的地址 仅仅是把标号换成了数值
2.16位间接绝对近调用
call bx		在bx取得地址
call [0x0300] 到内存取得地址 下同
call [bx]
call [bx+si+0x02]
和上面不同的是 执行时 会把ip的值压栈,然后直接用该数值赋值给ip 例如第二条 push ip ip=0x0300
近调用返回需要ret
3.16位直接绝对远调用
call 0x2000:0x0030
该跳转可以在段间进行,执行时,会把cs,ip的值压栈,把0x2000赋值给cs,0x0030赋值给ip,就算你跳转到原来的段,cpu也会进行同样的操作
4.16位间接绝对远调用
call far [0x2000]
也是段间调用,注意使用关键词far,调用时会将DS作为段地址,0x2000作为偏移地址,到内存取得一个字,
低地址为偏移地址,高地址为段地址,然后赋值给ip,cs 返回需要retf 
又如
sign dw 0x33c0,0xf000
call far [sign]会将高字0xf000赋给cs,低字0x33c0赋给ip
灵活运用ret retf可以实现跳转 ret retf可以独立使用

cmp指令 
作用和sub相同 但不保留计算结果 仅影响标志位
![](http://7xqhly.com1.z0.glb.clouddn.com/63.PNG)
![](http://7xqhly.com1.z0.glb.clouddn.com/632.PNG)

rep指令
重复执行直到cx为0

inc指令
inc al
inc byte [bx]
inc word [label_a]

or指令
逻辑或 影响:of,cf清零 sf,zf,pf依照结果决定

and指令
逻辑与 影响同上

push和pop指令
每次push ip都会自减2 从高地址向低地址压栈 push不影响标志位 
push的操作数可以是寄存器、内存单元里面的数值 压入的只是数值 可以pop给其它寄存器
push和pop只是为了方便 push ax等同于 sub sp,2 mov bx,sp mov [ss:bx],ax
push和pop应该平衡 push 和 pop应该成对

adc指令
带进位加法 将目的操作数和源操作数相加再加上标志寄存器cf的值
例如两个4字节数相加,需要分两次进行,先低两字节相加再高两字节相加,在高两字节相加时，要把低两字节相加以后可能出现的进位考虑进去，
adc指令实现这点很方便。例如adc ax,2 其实是将ax,2,CF三个数相加(ADD仅仅是前两个),所以能实现进位

shr和shl指令
shr 右移 shl 左移 每移一次 挤出来的比特会被移动到cf位 目的操作数可以是8位16位的通用寄存器或内存单元 源操作数可以是数字1,8位立即数,
或者寄存器cl,由于cl仅仅代表次数,不表示长度所以目的操作数是内存时需要限定:shr byte [bx],cl
80286以后的处理器会在执行前,将源操作数的高3位清零,即最大可移31位

ror和rol指令
ror 循环右移 rol循环左移 和上面的shr shl的指令格式是相同的 移出的比特既送进空出来的位,也会送到cf

hlt指令 
进入停机状态(可以响应中断)

nor指令
按位取反

test指令
功能上和and指令是一样的,都是按照两个操作数按位与,并设置标志位,但是test不会保留结果

resb伪指令
resb 256表示保留256字节
resw 100 保留100个字 
resd保留50个双字

指令对标志位的影响
![](http://7xqhly.com1.z0.glb.clouddn.com/6254.PNG)

内存中批量数据传输
原数据地址有DS:SI指定,目标地址由ES:DI指定 传送的字节数或字数由SI指定
指定传送方向:通过df位 
正向传送一个字或字节,SI,DI自加1或2,反向则相反
每传送一次 cs自减1

*以上截图来自《x86汇编语言 从实模式到保护模式》
