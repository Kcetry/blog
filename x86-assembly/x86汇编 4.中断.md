中断:实际上是对不确定何时发生是否发生的事件的一种处理,就如同if语句一样
8086中断分为 不可屏蔽（NMI)和可屏蔽中断
NMI通常会导致不可纠正的错误,被赋予统一的中断号2
可屏蔽中断通过intr引脚连接cpu 外部中断信号交由两块8259芯片处理 
![](http://7xqhly.com1.z0.glb.clouddn.com/126323.PNG)
intel处理器允许256个中断 中断号(0-255) 8259共可处理15个 中断号不固定
8259内还有IMR 可以通过设置0和1决定外设的中断能否通过(1表示不可 0表示可以)
主片端口号0x20和0x21 从片端口0xa0和0xa1 可以通过这些端口设置IMR和工作方式
主片的引脚0连接系统定时器/计数器 从片引脚0连接RTC
最终cpu是否响应中断还要看IF,若IF=0,从INTR来的中断都会被忽略,IF=1可响应
IF通过cli和sti指令改变 cli清除 sti置1

cpu可识别256个中断,那么理论上就需要256段程序,而且在实模式下,需要放到0x00000-0x003ff处,共1K的空间,
称为中断向量表(IVT) 每个中断占2个字,分别是偏移地址和段地址
当中断发生,cpu执行完当前指令后会立即告诉8259已准备好处理,并且要求8259把中断号送过来
cpu根据中断号 在执行中断程序前会保护现场 先把标志寄存器压栈 清除IF和TF位 然后根据中断号从表中取出段地址偏移地址
送到cs ip 如果希望在中断程序中处理更高等级的中断 可以用sti将IF置1
所有中断程序的最后一条是中断返回指令iret,处理器依次从栈中弹出IP,CS,FLAGS 由于IF位已经恢复 所以又可以接受中断了
当NMI发生,cpu自动生成中断号2
中断向量表的建立和初始化是BIOS负责的 BIOS为每个中断号填写入口地址 该地址只有iret指令 用户可自行修改该表

BCD编码 一个字节的高4位和低4位分别独立地表示一个0-9之间的数(每个4位不能大于1001) 例如25对应0001000101

![](http://7xqhly.com1.z0.glb.clouddn.com/1263.PNG)
ICH内部集成了RTC(实时时钟电路,负责计时)和CMOS RAM,CMOS RAM占用了128字节 时间日期占用了其中的10字节
0x70 0x74端口用于指定索引号 0x71 0x75是数据口 一下指令可以读出星期几
mov al,0x06
out 0x70,al
in al,0x71
端口0x70的最高位是控制NMI中断的开关,为0时允许NMI中断,其它7位用于指定索引号
索引号最后4个是寄存器,ABD可读可写,C只读,都是8位寄存器,含义如下表
![](http://7xqhly.com1.z0.glb.clouddn.com/a.PNG)
![](http://7xqhly.com1.z0.glb.clouddn.com/a2.PNG)
![](http://7xqhly.com1.z0.glb.clouddn.com/b2.PNG)
![](http://7xqhly.com1.z0.glb.clouddn.com/c.PNG)
![](http://7xqhly.com1.z0.glb.clouddn.com/d.PNG)


C寄存器每次读后所有位都会清零,而且不读相应位不会清0,导致中断不再产生

要改变代码段和数据段,只要改变段寄存器就可以,但栈段不同,除了有段寄存器还有栈指针,栈的改变分两步进行
先改变SS 再改变SP  中断依靠栈工作的 当改变了SS后发生了中断,压栈时就会把数据保存到错误的地方

当处理器执行任何一条改变ss的指令时,会在下一条指令执行完之前禁止中断
应该在SS后接改变sp的指令

BIOS会在计算机启动时 将主片的中断号设为从0x08开始,从片中断号从0x70开始,因为从片第一个
引脚连接的就是RTC,所以RTC中断号是0x70 可以改变

需要在中断程序中 发送中断结束命令(EOI)标明中断结束,代码是0x20
      mov al,0x20                        ;中断结束命令EOI
      out 0xa0,al                        ;向从片发送
      out 0x20,al                        ;向主片发送


内部中断:发生在cpu内部 如除数为0,除法结果溢出,遇到非法指令将产生中断6 内部中断不受IF影响

软中断:int指令引起的中断,int3是断点中断指令 int n表示引发n号中断 into是溢出中断指令,执行时如果cpu检测到
OF=1,将产生4号中断

软中断的好处是不需要知道中断的程序入口地址,方便调用例程,例如操作系统把读取硬盘的代码放到
中断向量表0x05这个地方,用户只要调用int 5就可以读硬盘了,不像jmp call需要提供一个明确的地址

bios中断: 不同的硬件使用不同的中断号,例如 int 0x16是键盘服务,AH指定某硬件的功能 例如从键盘读取一个按键:
mov ah,0x00
int 0x16; 
bios中断是在bios执行期间安装的
bios是如何知道访问硬件的?有些bios会为一些简单的外设提供初始化代码和功能调用,并提供向量表,
也有一些bios中断是外部设备自己建立的,有些外设有自己的ROM类似于BIOS,ROM中提供来它的功能调用,前两个单元是
0x55,0xaa,第三个是以512为字节的代码长度,第四个单元开始就是ROM代码,我们知道内存从A0000-FFFFF
是留给外设的,如果设备存在,自带的ROM会映射到相应的内存地址,启动时BIOS会以2KB为单位搜索C0000-E0000
,当它发现某区域开头是0x55AA时,就会比较该区域长度是否和第三个单元的数值相符,相符就从第四个单元进入
,最后填写中断向量表指向自带的中断处理程序




